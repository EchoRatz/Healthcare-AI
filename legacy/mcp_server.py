#!/usr/bin/env python3
"""
üåê Simple MCP Server - Model Context Protocol Server
‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå MCP ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏á‡πà‡∏≤‡∏¢‡πÅ‡∏•‡∏∞‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏á‡πà‡∏≤‡∏¢

Author: Refactored Version  
Date: 2025-07-31
"""
import asyncio
import json
import struct
import sys
import platform
from typing import Dict, Any, Optional
from datetime import datetime


class MCPServer:
    """MCP Server ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏á‡πà‡∏≤‡∏¢"""
    
    def __init__(self, name: str = "simple-mcp-server", version: str = "2.0.0"):
        self.name = name
        self.version = version
        self.initialized = False
        
        # Tools ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
        self.tools = {
            "echo": {
                "name": "echo",
                "description": "‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ",
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "message": {"type": "string", "description": "‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ echo"}
                    },
                    "required": ["message"]
                }
            },
            "calculate": {
                "name": "calculate",
                "description": "‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç (‡∏ö‡∏ß‡∏Å ‡∏•‡∏ö ‡∏Ñ‡∏π‡∏ì ‡∏´‡∏≤‡∏£)",
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "operation": {"type": "string", "enum": ["add", "subtract", "multiply", "divide"]},
                        "a": {"type": "number", "description": "‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà 1"},
                        "b": {"type": "number", "description": "‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà 2"}
                    },
                    "required": ["operation", "a", "b"]
                }
            },
            "system_info": {
                "name": "system_info", 
                "description": "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö",
                "inputSchema": {
                    "type": "object",
                    "properties": {},
                    "required": []
                }
            }
        }
        
        # Resources ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á
        self.resources = {
            "greeting": {
                "uri": "memory://greeting",
                "name": "‡∏Ñ‡∏≥‡∏ó‡∏±‡∏Å‡∏ó‡∏≤‡∏¢",
                "description": "‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏±‡∏Å‡∏ó‡∏≤‡∏¢‡∏à‡∏≤‡∏Å MCP Server",
                "mimeType": "text/plain"
            },
            "server_status": {
                "uri": "memory://status", 
                "name": "‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå",
                "description": "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå",
                "mimeType": "application/json"
            }
        }
        
        # Prompts ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ
        self.prompts = {
            "introduce": {
                "name": "introduce",
                "description": "‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á",
                "arguments": [
                    {"name": "name", "description": "‡∏ä‡∏∑‡πà‡∏≠‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥", "required": True}
                ]
            }
        }
    
    def create_response(self, request_id: Optional[int], result: Any = None, error: Optional[Dict] = None) -> Dict:
        """‡∏™‡∏£‡πâ‡∏≤‡∏á response message"""
        response = {
            "jsonrpc": "2.0",
            "id": request_id
        }
        
        if error:
            response["error"] = error
        else:
            response["result"] = result
        
        return response
    
    def create_error(self, code: int, message: str, data: Any = None) -> Dict:
        """‡∏™‡∏£‡πâ‡∏≤‡∏á error object"""
        error = {"code": code, "message": message}
        if data:
            error["data"] = data
        return error
    
    async def handle_initialize(self, params: Dict) -> Dict:
        """‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ initialize request"""
        self.initialized = True
        
        return {
            "protocolVersion": "2024-11-05",
            "capabilities": {
                "tools": {"listChanged": True},
                "resources": {"listChanged": True, "subscribe": True},
                "prompts": {"listChanged": True}
            },
            "serverInfo": {
                "name": self.name,
                "version": self.version
            }
        }
    
    async def handle_tools_list(self, params: Dict) -> Dict:
        """‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ tools"""
        return {"tools": list(self.tools.values())}
    
    async def handle_tools_call(self, params: Dict) -> Dict:
        """‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ tool"""
        tool_name = params.get("name")
        arguments = params.get("arguments", {})
        
        if tool_name not in self.tools:
            raise ValueError(f"‡πÑ‡∏°‡πà‡∏°‡∏µ tool ‡∏ä‡∏∑‡πà‡∏≠: {tool_name}")
        
        if tool_name == "echo":
            message = arguments.get("message", "")
            return {
                "content": [{"type": "text", "text": f"üì¢ Echo: {message}"}]
            }
        
        elif tool_name == "calculate":
            operation = arguments.get("operation")
            a = arguments.get("a", 0)
            b = arguments.get("b", 0)
            
            try:
                if operation == "add":
                    result = a + b
                elif operation == "subtract":
                    result = a - b
                elif operation == "multiply":
                    result = a * b
                elif operation == "divide":
                    if b == 0:
                        raise ValueError("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏´‡∏≤‡∏£‡∏î‡πâ‡∏ß‡∏¢‡∏®‡∏π‡∏ô‡∏¢‡πå‡πÑ‡∏î‡πâ")
                    result = a / b
                else:
                    raise ValueError(f"‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì: {operation}")
                
                return {
                    "content": [{"type": "text", "text": f"üßÆ {a} {operation} {b} = {result}"}]
                }
            except Exception as e:
                raise ValueError(f"‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì: {str(e)}")
        
        elif tool_name == "system_info":
            info = {
                "platform": platform.system(),
                "python_version": platform.python_version(),
                "timestamp": datetime.now().isoformat(),
                "server": f"{self.name} v{self.version}"
            }
            
            info_text = "\n".join([f"{k}: {v}" for k, v in info.items()])
            
            return {
                "content": [{"type": "text", "text": f"üíª ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏ö‡∏ö:\n{info_text}"}]
            }
        
        raise ValueError(f"‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏à‡∏±‡∏Å tool: {tool_name}")
    
    async def handle_resources_list(self, params: Dict) -> Dict:
        """‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ resources"""
        return {"resources": list(self.resources.values())}
    
    async def handle_resources_read(self, params: Dict) -> Dict:
        """‡∏≠‡πà‡∏≤‡∏ô resource"""
        uri = params.get("uri")
        
        if uri == "memory://greeting":
            content = f"üëã ‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏à‡∏≤‡∏Å {self.name}!\n\n‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏´‡πâ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÅ‡∏•‡πâ‡∏ß\n‡πÄ‡∏ß‡∏•‡∏≤: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
            return {
                "contents": [{"uri": uri, "mimeType": "text/plain", "text": content}]
            }
        
        elif uri == "memory://status":
            status = {
                "server_name": self.name,
                "version": self.version,
                "initialized": self.initialized,
                "timestamp": datetime.now().isoformat(),
                "available_tools": len(self.tools),
                "available_resources": len(self.resources),
                "available_prompts": len(self.prompts)
            }
            
            return {
                "contents": [{"uri": uri, "mimeType": "application/json", "text": json.dumps(status, indent=2)}]
            }
        
        raise ValueError(f"‡πÑ‡∏°‡πà‡∏û‡∏ö resource: {uri}")
    
    async def handle_prompts_list(self, params: Dict) -> Dict:
        """‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ prompts"""
        return {"prompts": list(self.prompts.values())}
    
    async def handle_prompts_get(self, params: Dict) -> Dict:
        """‡πÉ‡∏ä‡πâ prompt"""
        name = params.get("name")
        arguments = params.get("arguments", {})
        
        if name == "introduce":
            user_name = arguments.get("name", "‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ")
            prompt_text = f"‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ {user_name}! ‡∏â‡∏±‡∏ô‡∏Ñ‡∏∑‡∏≠ {self.name} ‡∏â‡∏±‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏Ñ‡∏∏‡∏ì‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô MCP Protocol"
            
            return {
                "description": f"‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏ï‡∏±‡∏ß‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö {user_name}",
                "messages": [
                    {"role": "user", "content": {"type": "text", "text": prompt_text}}
                ]
            }
        
        raise ValueError(f"‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏à‡∏±‡∏Å prompt: {name}")
    
    async def handle_request(self, request: Dict) -> Dict:
        """‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ request"""
        method = request.get("method")
        params = request.get("params", {})
        request_id = request.get("id")
        
        try:
            if method == "initialize":
                result = await self.handle_initialize(params)
            elif method == "tools/list":
                result = await self.handle_tools_list(params)
            elif method == "tools/call":
                result = await self.handle_tools_call(params)
            elif method == "resources/list":
                result = await self.handle_resources_list(params)
            elif method == "resources/read":
                result = await self.handle_resources_read(params)
            elif method == "prompts/list":
                result = await self.handle_prompts_list(params)
            elif method == "prompts/get":
                result = await self.handle_prompts_get(params)
            else:
                raise ValueError(f"‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö method: {method}")
            
            return self.create_response(request_id, result)
        
        except Exception as e:
            error = self.create_error(-32603, f"Internal error: {str(e)}")
            return self.create_response(request_id, error=error)
    
    async def read_message(self, reader: asyncio.StreamReader) -> Optional[Dict]:
        """‡∏≠‡πà‡∏≤‡∏ô message ‡∏à‡∏≤‡∏Å stream"""
        try:
            # ‡∏≠‡πà‡∏≤‡∏ô length (4 bytes)
            length_data = await reader.read(4)
            if not length_data:
                return None
            
            length = struct.unpack('>I', length_data)[0]
            
            # ‡∏≠‡πà‡∏≤‡∏ô message
            message_data = await reader.read(length)
            if len(message_data) != length:
                return None
            
            # ‡πÅ‡∏õ‡∏•‡∏á JSON
            message = json.loads(message_data.decode('utf-8'))
            return message
        
        except Exception as e:
            print(f"‚ùå Error reading message: {e}")
            return None
    
    async def write_message(self, writer: asyncio.StreamWriter, message: Dict):
        """‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô message ‡πÑ‡∏õ‡∏¢‡∏±‡∏á stream"""
        try:
            # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô JSON
            message_json = json.dumps(message, ensure_ascii=False)
            message_bytes = message_json.encode('utf-8')
            
            # ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô length ‡πÅ‡∏•‡∏∞ message
            length = len(message_bytes)
            writer.write(struct.pack('>I', length))
            writer.write(message_bytes)
            await writer.drain()
        
        except Exception as e:
            print(f"‚ùå Error writing message: {e}")
    
    async def handle_client(self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter):
        """‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ client connection"""
        client_addr = writer.get_extra_info('peername')
        print(f"üîó Client connected: {client_addr}")
        
        try:
            while True:
                message = await self.read_message(reader)
                if message is None:
                    break
                
                print(f"üì® Received: {message.get('method', 'unknown')} (id: {message.get('id')})")
                
                response = await self.handle_request(message)
                await self.write_message(writer, response)
                
                print(f"üì§ Sent response for id: {response.get('id')}")
        
        except Exception as e:
            print(f"‚ùå Error handling client: {e}")
        
        finally:
            print(f"üîå Client disconnected: {client_addr}")
            writer.close()
            await writer.wait_closed()
    
    async def start_server(self, host: str = "localhost", port: int = 8765):
        """‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå"""
        server = await asyncio.start_server(self.handle_client, host, port)
        addr = server.sockets[0].getsockname()
        
        print(f"üöÄ {self.name} v{self.version} ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô")
        print(f"üåê ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà: {addr[0]}:{addr[1]}")
        print(f"üîß Tools: {len(self.tools)}")
        print(f"üìÑ Resources: {len(self.resources)}")
        print(f"üí° Prompts: {len(self.prompts)}")
        print("=" * 50)
        print("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠... (‡∏Å‡∏î Ctrl+C ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏¢‡∏∏‡∏î)")
        
        async with server:
            await server.serve_forever()


async def main():
    """‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏Å"""
    print("üåê Simple MCP Server (Refactored)")
    print("Model Context Protocol Server ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏á‡πà‡∏≤‡∏¢")
    
    server = MCPServer()
    
    try:
        await server.start_server()
    except KeyboardInterrupt:
        print("\n\nüëã ‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô")
    except Exception as e:
        print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {e}")


if __name__ == "__main__":
    asyncio.run(main())
